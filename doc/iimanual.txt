.ii MANUAL

.ii files are distro agnostic init files. During the build process of
initng, the distro specific .i files are generated by the install_process
program.

You may see the install_process program as something like an C preprocessor.
Basically the .ii files are copied line by line into the .i file. However
there are special constructs that can be used to generate distro-specic
code.

These constructs are:

    #exec blocks

    #ifd blocks

    @foo@ statements


#exec BLOCKS:

the exec blocks starts with an "#exec" line, and ends with an "#endexec"
line. Everything between "#exec" and "#endexec" is executed as a shell
script. The output of the shell script is copied into the .i file.

Example:

    #exec
    echo foo
    #endexec

This will create the line "foo" in the .i file.



#ifd BLOCKS:

An #ifd block starts with a "#ifd DISTRO" line, and ends with an "#endd"
line.

install_process will try to probe your distribution and copy the contents of
the Block into the .i file if your distribution is contained in DISTRO.

There may be one ore more "#elsed" line inside the #ifd Block. Think of it
as "else" or "else if" in C.

Let's explain by an example:

    #ifd gentoo
    foo
    #elsed debian ubuntu
    bar
    #elsed
    baz
    #endd

This will produce the line "foo" on gentoo, "bar" on debian and ubuntu, and
"baz" on every other distro. There must be no "#elsed DISTRO" lines after an
"#elsed" line with no distro specifier.



@foo@ STATEMENTS:

You know this problem: udhcpc is installed in /sbin on one distro, and in
/usr/sbin in some other distro. Here the @foo@ statements kick in.

in its basic form, @foo@ will search the PATH for the executable foo, and if
found, it will replace @foo@ with the path of the foo executable.

In addition to the users PATH, install_service will also search in /sbin,
/usr/sbin and /usr/local/sbin. this will allow building initng by
unpriviliged users, whose PATH usually does not contain these directorys.

But what if no foo executable is found? (This might be the case if the
package foo wasn't installed when the user built initng.) In this case,
install_process will use a builtin default path (/usr/sbin), so if no foo
executable is found, @foo@ will produce /usr/sbin/foo.

This default path might not be sufficient for all services, so you have
several possibilities to change it.


#atdefpath:

Use #atdefpath. You can override the builtin default path usr/sbin with it.
If you place an "#atdefpath /usr/bin" line in the .ii file before_ the
@foo@ statement, this for example will override the default path
with /usr/bin.

Any subsequent #atdefpath lines will _override_ previous default paths.

#atdefpath also supports a special feature called multi-line default paths.
An example:

    #atdefpath /usr/bin:/bin:/usr/local/bin
    daemon = @foo@

If a foo executable is not found in the PATH, the "daemon = @foo@" line will
not generate one output line, but three:

    daemon = /usr/bin/foo
    daemon = /bin/foo
    daemon = /usr/local/bin/foo


@/path/file@:

If you use the @/my/path/foo@ construct, install_service will at first look
/if my/path/foo exits. if yes, this line is printed. if no, the PATH is
searched for foo. If install_service can find it in the PATH, then it will
produce a /usr/sbin/foo, if it was found eg. in /usr/sbin. If it also
couldn't be found in the path, then /my/path/foo will be created. Any
previous set default paths will be ignored.


@foo:bar@:

But when you code distro agnostic .ii files, you might also arrive at
another problem: one distro names your daemon "dbus-deamon", while another
has "dbus-daemon-1". to solve this, you can write a statement like:
"@dbus-daemon:dbus-daemon-1@". First, install_process will search your PATH
for dbus-daemon. If it can't find it, it will search the PATH for
dbus-daemon-1. If it also can't find dbus-daemon-1, it will fall back on
dbus-daemon (the first name specified), using the default path (either
builtin or from #atdefpath). You also can write lines like
@/usr/bin/dbus-daemon:dbus-daemon-1@.

Note that this might produce multiple output lines if you use an multi-line
default path, but it will only produce output from the _first_ element.
